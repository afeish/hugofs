// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             (unknown)
// source: meta/storage.proto

package meta

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	StorageMeta_LoadConfiguration_FullMethodName             = "/hugo.v1.meta.StorageMeta/LoadConfiguration"
	StorageMeta_Statistics_FullMethodName                    = "/hugo.v1.meta.StorageMeta/Statistics"
	StorageMeta_BeginTransaction_FullMethodName              = "/hugo.v1.meta.StorageMeta/BeginTransaction"
	StorageMeta_CommitTransaction_FullMethodName             = "/hugo.v1.meta.StorageMeta/CommitTransaction"
	StorageMeta_RollbackTransaction_FullMethodName           = "/hugo.v1.meta.StorageMeta/RollbackTransaction"
	StorageMeta_GetPhysicalVolume_FullMethodName             = "/hugo.v1.meta.StorageMeta/GetPhysicalVolume"
	StorageMeta_GetVirtualVolume_FullMethodName              = "/hugo.v1.meta.StorageMeta/GetVirtualVolume"
	StorageMeta_ListPhysicalVolumes_FullMethodName           = "/hugo.v1.meta.StorageMeta/ListPhysicalVolumes"
	StorageMeta_ListVirtualVolume_FullMethodName             = "/hugo.v1.meta.StorageMeta/ListVirtualVolume"
	StorageMeta_GetInoBlockMap_FullMethodName                = "/hugo.v1.meta.StorageMeta/GetInoBlockMap"
	StorageMeta_GetHistoryBlockMap_FullMethodName            = "/hugo.v1.meta.StorageMeta/GetHistoryBlockMap"
	StorageMeta_GetInoBlockMeta_FullMethodName               = "/hugo.v1.meta.StorageMeta/GetInoBlockMeta"
	StorageMeta_UpdateBlockLocation_FullMethodName           = "/hugo.v1.meta.StorageMeta/UpdateBlockLocation"
	StorageMeta_BatchUpdateBlockLocation_FullMethodName      = "/hugo.v1.meta.StorageMeta/BatchUpdateBlockLocation"
	StorageMeta_CreatePhysicalVolume_FullMethodName          = "/hugo.v1.meta.StorageMeta/CreatePhysicalVolume"
	StorageMeta_PatchPhysicalVolume_FullMethodName           = "/hugo.v1.meta.StorageMeta/PatchPhysicalVolume"
	StorageMeta_CreateVirtualVolume_FullMethodName           = "/hugo.v1.meta.StorageMeta/CreateVirtualVolume"
	StorageMeta_CreateReadOnlyVirtualVolume_FullMethodName   = "/hugo.v1.meta.StorageMeta/CreateReadOnlyVirtualVolume"
	StorageMeta_BindPhysicalVolToVirtualVol_FullMethodName   = "/hugo.v1.meta.StorageMeta/BindPhysicalVolToVirtualVol"
	StorageMeta_UnBindPhysicalVolToVirtualVol_FullMethodName = "/hugo.v1.meta.StorageMeta/UnBindPhysicalVolToVirtualVol"
	StorageMeta_HeartBeat_FullMethodName                     = "/hugo.v1.meta.StorageMeta/HeartBeat"
)

// StorageMetaClient is the client API for StorageMeta service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type StorageMetaClient interface {
	// load storage configuration
	LoadConfiguration(ctx context.Context, in *LoadConfiguration_Request, opts ...grpc.CallOption) (*LoadConfiguration_Response, error)
	// Statistics returns usage.
	Statistics(ctx context.Context, in *Statistics_Request, opts ...grpc.CallOption) (*Statistics_Response, error)
	// ////////////////////////////////////////////////
	// BeginTransaction will result the transaction_id increase.
	// Make each virtual volume holds a separate transaction to avoid overflow.
	BeginTransaction(ctx context.Context, in *BeginTransaction_Request, opts ...grpc.CallOption) (*BeginTransaction_Response, error)
	// CommitTransaction will commit the transaction to make the change visible.
	// By removing the given transaction id from the active transaction list.
	CommitTransaction(ctx context.Context, in *CommitTransaction_Request, opts ...grpc.CallOption) (*CommitTransaction_Response, error)
	// RollbackTransaction will rollback the transaction, by deleting the changes with the given transaction id.
	RollbackTransaction(ctx context.Context, in *RollbackTransaction_Request, opts ...grpc.CallOption) (*RollbackTransaction_Response, error)
	// ////////////////////////////////////////////////
	// GetPhysicalVolume gets the physical volume by id. At present cannot know the history of the physical volume.
	GetPhysicalVolume(ctx context.Context, in *GetPhysicalVolume_Request, opts ...grpc.CallOption) (*GetPhysicalVolume_Response, error)
	// Get the virtual volume by id. At present cannot know the history of the virtual volume.
	GetVirtualVolume(ctx context.Context, in *GetVirtualVolume_Request, opts ...grpc.CallOption) (*GetVirtualVolume_Response, error)
	// ListPhysicalVolumes lists all physical volumes.
	ListPhysicalVolumes(ctx context.Context, in *ListPhysicalVolumes_Request, opts ...grpc.CallOption) (*ListPhysicalVolumes_Response, error)
	// ListVirtualVolume lists all virtual volumes.
	ListVirtualVolume(ctx context.Context, in *ListVirtualVolume_Request, opts ...grpc.CallOption) (*ListVirtualVolume_Response, error)
	// ////////////////////////////////////////////////
	// GetLatestInoBlockMap gets the block map of a file with a transaction id.
	// If no transaction id is given, it will return the latest block map.
	GetInoBlockMap(ctx context.Context, in *GetInoBlockMap_Request, opts ...grpc.CallOption) (*GetInoBlockMap_Response, error)
	GetHistoryBlockMap(ctx context.Context, in *GetInoBlockMap_Request, opts ...grpc.CallOption) (*GetInoBlockMap_Response, error)
	// GetInoBlockMeta gets the block metadata, with the transaction_id, we can have a history view of the file.
	GetInoBlockMeta(ctx context.Context, in *GetInoBlockMeta_Request, opts ...grpc.CallOption) (*GetInoBlockMeta_Response, error)
	// ////////////////////////////////////////////////
	// UpdateBlockLocation updates the block location of a file.
	UpdateBlockLocation(ctx context.Context, in *UpdateBlockLocation_Request, opts ...grpc.CallOption) (*UpdateBlockLocation_Response, error)
	// BatchUpdateBlockLocation updates the block location of a file.
	BatchUpdateBlockLocation(ctx context.Context, in *BatchUpdateBlockLocation_Request, opts ...grpc.CallOption) (*BatchUpdateBlockLocation_Response, error)
	// ////////////////////////////////////////////////
	// CreatePhysicalVolume creates a physical volume.
	CreatePhysicalVolume(ctx context.Context, in *CreatePhysicalVolume_Request, opts ...grpc.CallOption) (*CreatePhysicalVolume_Response, error)
	// PatchPhysicalVolume patch the update of the physical volume
	PatchPhysicalVolume(ctx context.Context, in *PatchPhysicalVolume_Request, opts ...grpc.CallOption) (*PatchPhysicalVolume_Response, error)
	// CreateVirtualVolume creates a virtual volume.
	CreateVirtualVolume(ctx context.Context, in *CreateVirtualVolume_Request, opts ...grpc.CallOption) (*CreateVirtualVolume_Response, error)
	// CreateReadOnlyVirtualVolume creates a read only virtual volume.
	CreateReadOnlyVirtualVolume(ctx context.Context, in *CreateReadOnlyVirtualVolume_Request, opts ...grpc.CallOption) (*CreateReadOnlyVirtualVolume_Response, error)
	// ////////////////////////////////////////////////
	// BindPhysicalVolToVirtualVol binds physical volumes to a virtual volume.
	BindPhysicalVolToVirtualVol(ctx context.Context, in *BindPhysicalVolToVirtualVol_Request, opts ...grpc.CallOption) (*BindPhysicalVolToVirtualVol_Response, error)
	// UnBindPhysicalVolToVirtualVol unbinds physical volumes from a virtual volume.
	UnBindPhysicalVolToVirtualVol(ctx context.Context, in *UnBindPhysicalVolToVirtualVol_Request, opts ...grpc.CallOption) (*UnBindPhysicalVolToVirtualVol_Response, error)
	// ////////////////////////////////////////////////
	// HeartBeat is a heartbeat of the storage node.
	// It can be used to check the health of the storage node.
	// It is also used to distribute event to the storage node.
	HeartBeat(ctx context.Context, opts ...grpc.CallOption) (StorageMeta_HeartBeatClient, error)
}

type storageMetaClient struct {
	cc grpc.ClientConnInterface
}

func NewStorageMetaClient(cc grpc.ClientConnInterface) StorageMetaClient {
	return &storageMetaClient{cc}
}

func (c *storageMetaClient) LoadConfiguration(ctx context.Context, in *LoadConfiguration_Request, opts ...grpc.CallOption) (*LoadConfiguration_Response, error) {
	out := new(LoadConfiguration_Response)
	err := c.cc.Invoke(ctx, StorageMeta_LoadConfiguration_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageMetaClient) Statistics(ctx context.Context, in *Statistics_Request, opts ...grpc.CallOption) (*Statistics_Response, error) {
	out := new(Statistics_Response)
	err := c.cc.Invoke(ctx, StorageMeta_Statistics_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageMetaClient) BeginTransaction(ctx context.Context, in *BeginTransaction_Request, opts ...grpc.CallOption) (*BeginTransaction_Response, error) {
	out := new(BeginTransaction_Response)
	err := c.cc.Invoke(ctx, StorageMeta_BeginTransaction_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageMetaClient) CommitTransaction(ctx context.Context, in *CommitTransaction_Request, opts ...grpc.CallOption) (*CommitTransaction_Response, error) {
	out := new(CommitTransaction_Response)
	err := c.cc.Invoke(ctx, StorageMeta_CommitTransaction_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageMetaClient) RollbackTransaction(ctx context.Context, in *RollbackTransaction_Request, opts ...grpc.CallOption) (*RollbackTransaction_Response, error) {
	out := new(RollbackTransaction_Response)
	err := c.cc.Invoke(ctx, StorageMeta_RollbackTransaction_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageMetaClient) GetPhysicalVolume(ctx context.Context, in *GetPhysicalVolume_Request, opts ...grpc.CallOption) (*GetPhysicalVolume_Response, error) {
	out := new(GetPhysicalVolume_Response)
	err := c.cc.Invoke(ctx, StorageMeta_GetPhysicalVolume_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageMetaClient) GetVirtualVolume(ctx context.Context, in *GetVirtualVolume_Request, opts ...grpc.CallOption) (*GetVirtualVolume_Response, error) {
	out := new(GetVirtualVolume_Response)
	err := c.cc.Invoke(ctx, StorageMeta_GetVirtualVolume_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageMetaClient) ListPhysicalVolumes(ctx context.Context, in *ListPhysicalVolumes_Request, opts ...grpc.CallOption) (*ListPhysicalVolumes_Response, error) {
	out := new(ListPhysicalVolumes_Response)
	err := c.cc.Invoke(ctx, StorageMeta_ListPhysicalVolumes_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageMetaClient) ListVirtualVolume(ctx context.Context, in *ListVirtualVolume_Request, opts ...grpc.CallOption) (*ListVirtualVolume_Response, error) {
	out := new(ListVirtualVolume_Response)
	err := c.cc.Invoke(ctx, StorageMeta_ListVirtualVolume_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageMetaClient) GetInoBlockMap(ctx context.Context, in *GetInoBlockMap_Request, opts ...grpc.CallOption) (*GetInoBlockMap_Response, error) {
	out := new(GetInoBlockMap_Response)
	err := c.cc.Invoke(ctx, StorageMeta_GetInoBlockMap_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageMetaClient) GetHistoryBlockMap(ctx context.Context, in *GetInoBlockMap_Request, opts ...grpc.CallOption) (*GetInoBlockMap_Response, error) {
	out := new(GetInoBlockMap_Response)
	err := c.cc.Invoke(ctx, StorageMeta_GetHistoryBlockMap_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageMetaClient) GetInoBlockMeta(ctx context.Context, in *GetInoBlockMeta_Request, opts ...grpc.CallOption) (*GetInoBlockMeta_Response, error) {
	out := new(GetInoBlockMeta_Response)
	err := c.cc.Invoke(ctx, StorageMeta_GetInoBlockMeta_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageMetaClient) UpdateBlockLocation(ctx context.Context, in *UpdateBlockLocation_Request, opts ...grpc.CallOption) (*UpdateBlockLocation_Response, error) {
	out := new(UpdateBlockLocation_Response)
	err := c.cc.Invoke(ctx, StorageMeta_UpdateBlockLocation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageMetaClient) BatchUpdateBlockLocation(ctx context.Context, in *BatchUpdateBlockLocation_Request, opts ...grpc.CallOption) (*BatchUpdateBlockLocation_Response, error) {
	out := new(BatchUpdateBlockLocation_Response)
	err := c.cc.Invoke(ctx, StorageMeta_BatchUpdateBlockLocation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageMetaClient) CreatePhysicalVolume(ctx context.Context, in *CreatePhysicalVolume_Request, opts ...grpc.CallOption) (*CreatePhysicalVolume_Response, error) {
	out := new(CreatePhysicalVolume_Response)
	err := c.cc.Invoke(ctx, StorageMeta_CreatePhysicalVolume_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageMetaClient) PatchPhysicalVolume(ctx context.Context, in *PatchPhysicalVolume_Request, opts ...grpc.CallOption) (*PatchPhysicalVolume_Response, error) {
	out := new(PatchPhysicalVolume_Response)
	err := c.cc.Invoke(ctx, StorageMeta_PatchPhysicalVolume_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageMetaClient) CreateVirtualVolume(ctx context.Context, in *CreateVirtualVolume_Request, opts ...grpc.CallOption) (*CreateVirtualVolume_Response, error) {
	out := new(CreateVirtualVolume_Response)
	err := c.cc.Invoke(ctx, StorageMeta_CreateVirtualVolume_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageMetaClient) CreateReadOnlyVirtualVolume(ctx context.Context, in *CreateReadOnlyVirtualVolume_Request, opts ...grpc.CallOption) (*CreateReadOnlyVirtualVolume_Response, error) {
	out := new(CreateReadOnlyVirtualVolume_Response)
	err := c.cc.Invoke(ctx, StorageMeta_CreateReadOnlyVirtualVolume_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageMetaClient) BindPhysicalVolToVirtualVol(ctx context.Context, in *BindPhysicalVolToVirtualVol_Request, opts ...grpc.CallOption) (*BindPhysicalVolToVirtualVol_Response, error) {
	out := new(BindPhysicalVolToVirtualVol_Response)
	err := c.cc.Invoke(ctx, StorageMeta_BindPhysicalVolToVirtualVol_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageMetaClient) UnBindPhysicalVolToVirtualVol(ctx context.Context, in *UnBindPhysicalVolToVirtualVol_Request, opts ...grpc.CallOption) (*UnBindPhysicalVolToVirtualVol_Response, error) {
	out := new(UnBindPhysicalVolToVirtualVol_Response)
	err := c.cc.Invoke(ctx, StorageMeta_UnBindPhysicalVolToVirtualVol_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageMetaClient) HeartBeat(ctx context.Context, opts ...grpc.CallOption) (StorageMeta_HeartBeatClient, error) {
	stream, err := c.cc.NewStream(ctx, &StorageMeta_ServiceDesc.Streams[0], StorageMeta_HeartBeat_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &storageMetaHeartBeatClient{stream}
	return x, nil
}

type StorageMeta_HeartBeatClient interface {
	Send(*HeartBeat_Request) error
	Recv() (*HeartBeat_Response, error)
	grpc.ClientStream
}

type storageMetaHeartBeatClient struct {
	grpc.ClientStream
}

func (x *storageMetaHeartBeatClient) Send(m *HeartBeat_Request) error {
	return x.ClientStream.SendMsg(m)
}

func (x *storageMetaHeartBeatClient) Recv() (*HeartBeat_Response, error) {
	m := new(HeartBeat_Response)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// StorageMetaServer is the server API for StorageMeta service.
// All implementations should embed UnimplementedStorageMetaServer
// for forward compatibility
type StorageMetaServer interface {
	// load storage configuration
	LoadConfiguration(context.Context, *LoadConfiguration_Request) (*LoadConfiguration_Response, error)
	// Statistics returns usage.
	Statistics(context.Context, *Statistics_Request) (*Statistics_Response, error)
	// ////////////////////////////////////////////////
	// BeginTransaction will result the transaction_id increase.
	// Make each virtual volume holds a separate transaction to avoid overflow.
	BeginTransaction(context.Context, *BeginTransaction_Request) (*BeginTransaction_Response, error)
	// CommitTransaction will commit the transaction to make the change visible.
	// By removing the given transaction id from the active transaction list.
	CommitTransaction(context.Context, *CommitTransaction_Request) (*CommitTransaction_Response, error)
	// RollbackTransaction will rollback the transaction, by deleting the changes with the given transaction id.
	RollbackTransaction(context.Context, *RollbackTransaction_Request) (*RollbackTransaction_Response, error)
	// ////////////////////////////////////////////////
	// GetPhysicalVolume gets the physical volume by id. At present cannot know the history of the physical volume.
	GetPhysicalVolume(context.Context, *GetPhysicalVolume_Request) (*GetPhysicalVolume_Response, error)
	// Get the virtual volume by id. At present cannot know the history of the virtual volume.
	GetVirtualVolume(context.Context, *GetVirtualVolume_Request) (*GetVirtualVolume_Response, error)
	// ListPhysicalVolumes lists all physical volumes.
	ListPhysicalVolumes(context.Context, *ListPhysicalVolumes_Request) (*ListPhysicalVolumes_Response, error)
	// ListVirtualVolume lists all virtual volumes.
	ListVirtualVolume(context.Context, *ListVirtualVolume_Request) (*ListVirtualVolume_Response, error)
	// ////////////////////////////////////////////////
	// GetLatestInoBlockMap gets the block map of a file with a transaction id.
	// If no transaction id is given, it will return the latest block map.
	GetInoBlockMap(context.Context, *GetInoBlockMap_Request) (*GetInoBlockMap_Response, error)
	GetHistoryBlockMap(context.Context, *GetInoBlockMap_Request) (*GetInoBlockMap_Response, error)
	// GetInoBlockMeta gets the block metadata, with the transaction_id, we can have a history view of the file.
	GetInoBlockMeta(context.Context, *GetInoBlockMeta_Request) (*GetInoBlockMeta_Response, error)
	// ////////////////////////////////////////////////
	// UpdateBlockLocation updates the block location of a file.
	UpdateBlockLocation(context.Context, *UpdateBlockLocation_Request) (*UpdateBlockLocation_Response, error)
	// BatchUpdateBlockLocation updates the block location of a file.
	BatchUpdateBlockLocation(context.Context, *BatchUpdateBlockLocation_Request) (*BatchUpdateBlockLocation_Response, error)
	// ////////////////////////////////////////////////
	// CreatePhysicalVolume creates a physical volume.
	CreatePhysicalVolume(context.Context, *CreatePhysicalVolume_Request) (*CreatePhysicalVolume_Response, error)
	// PatchPhysicalVolume patch the update of the physical volume
	PatchPhysicalVolume(context.Context, *PatchPhysicalVolume_Request) (*PatchPhysicalVolume_Response, error)
	// CreateVirtualVolume creates a virtual volume.
	CreateVirtualVolume(context.Context, *CreateVirtualVolume_Request) (*CreateVirtualVolume_Response, error)
	// CreateReadOnlyVirtualVolume creates a read only virtual volume.
	CreateReadOnlyVirtualVolume(context.Context, *CreateReadOnlyVirtualVolume_Request) (*CreateReadOnlyVirtualVolume_Response, error)
	// ////////////////////////////////////////////////
	// BindPhysicalVolToVirtualVol binds physical volumes to a virtual volume.
	BindPhysicalVolToVirtualVol(context.Context, *BindPhysicalVolToVirtualVol_Request) (*BindPhysicalVolToVirtualVol_Response, error)
	// UnBindPhysicalVolToVirtualVol unbinds physical volumes from a virtual volume.
	UnBindPhysicalVolToVirtualVol(context.Context, *UnBindPhysicalVolToVirtualVol_Request) (*UnBindPhysicalVolToVirtualVol_Response, error)
	// ////////////////////////////////////////////////
	// HeartBeat is a heartbeat of the storage node.
	// It can be used to check the health of the storage node.
	// It is also used to distribute event to the storage node.
	HeartBeat(StorageMeta_HeartBeatServer) error
}

// UnimplementedStorageMetaServer should be embedded to have forward compatible implementations.
type UnimplementedStorageMetaServer struct {
}

func (UnimplementedStorageMetaServer) LoadConfiguration(context.Context, *LoadConfiguration_Request) (*LoadConfiguration_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoadConfiguration not implemented")
}
func (UnimplementedStorageMetaServer) Statistics(context.Context, *Statistics_Request) (*Statistics_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Statistics not implemented")
}
func (UnimplementedStorageMetaServer) BeginTransaction(context.Context, *BeginTransaction_Request) (*BeginTransaction_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BeginTransaction not implemented")
}
func (UnimplementedStorageMetaServer) CommitTransaction(context.Context, *CommitTransaction_Request) (*CommitTransaction_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CommitTransaction not implemented")
}
func (UnimplementedStorageMetaServer) RollbackTransaction(context.Context, *RollbackTransaction_Request) (*RollbackTransaction_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RollbackTransaction not implemented")
}
func (UnimplementedStorageMetaServer) GetPhysicalVolume(context.Context, *GetPhysicalVolume_Request) (*GetPhysicalVolume_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPhysicalVolume not implemented")
}
func (UnimplementedStorageMetaServer) GetVirtualVolume(context.Context, *GetVirtualVolume_Request) (*GetVirtualVolume_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVirtualVolume not implemented")
}
func (UnimplementedStorageMetaServer) ListPhysicalVolumes(context.Context, *ListPhysicalVolumes_Request) (*ListPhysicalVolumes_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPhysicalVolumes not implemented")
}
func (UnimplementedStorageMetaServer) ListVirtualVolume(context.Context, *ListVirtualVolume_Request) (*ListVirtualVolume_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListVirtualVolume not implemented")
}
func (UnimplementedStorageMetaServer) GetInoBlockMap(context.Context, *GetInoBlockMap_Request) (*GetInoBlockMap_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInoBlockMap not implemented")
}
func (UnimplementedStorageMetaServer) GetHistoryBlockMap(context.Context, *GetInoBlockMap_Request) (*GetInoBlockMap_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHistoryBlockMap not implemented")
}
func (UnimplementedStorageMetaServer) GetInoBlockMeta(context.Context, *GetInoBlockMeta_Request) (*GetInoBlockMeta_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInoBlockMeta not implemented")
}
func (UnimplementedStorageMetaServer) UpdateBlockLocation(context.Context, *UpdateBlockLocation_Request) (*UpdateBlockLocation_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateBlockLocation not implemented")
}
func (UnimplementedStorageMetaServer) BatchUpdateBlockLocation(context.Context, *BatchUpdateBlockLocation_Request) (*BatchUpdateBlockLocation_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchUpdateBlockLocation not implemented")
}
func (UnimplementedStorageMetaServer) CreatePhysicalVolume(context.Context, *CreatePhysicalVolume_Request) (*CreatePhysicalVolume_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePhysicalVolume not implemented")
}
func (UnimplementedStorageMetaServer) PatchPhysicalVolume(context.Context, *PatchPhysicalVolume_Request) (*PatchPhysicalVolume_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PatchPhysicalVolume not implemented")
}
func (UnimplementedStorageMetaServer) CreateVirtualVolume(context.Context, *CreateVirtualVolume_Request) (*CreateVirtualVolume_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateVirtualVolume not implemented")
}
func (UnimplementedStorageMetaServer) CreateReadOnlyVirtualVolume(context.Context, *CreateReadOnlyVirtualVolume_Request) (*CreateReadOnlyVirtualVolume_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateReadOnlyVirtualVolume not implemented")
}
func (UnimplementedStorageMetaServer) BindPhysicalVolToVirtualVol(context.Context, *BindPhysicalVolToVirtualVol_Request) (*BindPhysicalVolToVirtualVol_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BindPhysicalVolToVirtualVol not implemented")
}
func (UnimplementedStorageMetaServer) UnBindPhysicalVolToVirtualVol(context.Context, *UnBindPhysicalVolToVirtualVol_Request) (*UnBindPhysicalVolToVirtualVol_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnBindPhysicalVolToVirtualVol not implemented")
}
func (UnimplementedStorageMetaServer) HeartBeat(StorageMeta_HeartBeatServer) error {
	return status.Errorf(codes.Unimplemented, "method HeartBeat not implemented")
}

// UnsafeStorageMetaServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StorageMetaServer will
// result in compilation errors.
type UnsafeStorageMetaServer interface {
	mustEmbedUnimplementedStorageMetaServer()
}

func RegisterStorageMetaServer(s grpc.ServiceRegistrar, srv StorageMetaServer) {
	s.RegisterService(&StorageMeta_ServiceDesc, srv)
}

func _StorageMeta_LoadConfiguration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadConfiguration_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageMetaServer).LoadConfiguration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StorageMeta_LoadConfiguration_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageMetaServer).LoadConfiguration(ctx, req.(*LoadConfiguration_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _StorageMeta_Statistics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Statistics_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageMetaServer).Statistics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StorageMeta_Statistics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageMetaServer).Statistics(ctx, req.(*Statistics_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _StorageMeta_BeginTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BeginTransaction_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageMetaServer).BeginTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StorageMeta_BeginTransaction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageMetaServer).BeginTransaction(ctx, req.(*BeginTransaction_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _StorageMeta_CommitTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommitTransaction_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageMetaServer).CommitTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StorageMeta_CommitTransaction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageMetaServer).CommitTransaction(ctx, req.(*CommitTransaction_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _StorageMeta_RollbackTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RollbackTransaction_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageMetaServer).RollbackTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StorageMeta_RollbackTransaction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageMetaServer).RollbackTransaction(ctx, req.(*RollbackTransaction_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _StorageMeta_GetPhysicalVolume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPhysicalVolume_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageMetaServer).GetPhysicalVolume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StorageMeta_GetPhysicalVolume_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageMetaServer).GetPhysicalVolume(ctx, req.(*GetPhysicalVolume_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _StorageMeta_GetVirtualVolume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVirtualVolume_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageMetaServer).GetVirtualVolume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StorageMeta_GetVirtualVolume_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageMetaServer).GetVirtualVolume(ctx, req.(*GetVirtualVolume_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _StorageMeta_ListPhysicalVolumes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPhysicalVolumes_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageMetaServer).ListPhysicalVolumes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StorageMeta_ListPhysicalVolumes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageMetaServer).ListPhysicalVolumes(ctx, req.(*ListPhysicalVolumes_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _StorageMeta_ListVirtualVolume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListVirtualVolume_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageMetaServer).ListVirtualVolume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StorageMeta_ListVirtualVolume_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageMetaServer).ListVirtualVolume(ctx, req.(*ListVirtualVolume_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _StorageMeta_GetInoBlockMap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInoBlockMap_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageMetaServer).GetInoBlockMap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StorageMeta_GetInoBlockMap_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageMetaServer).GetInoBlockMap(ctx, req.(*GetInoBlockMap_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _StorageMeta_GetHistoryBlockMap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInoBlockMap_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageMetaServer).GetHistoryBlockMap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StorageMeta_GetHistoryBlockMap_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageMetaServer).GetHistoryBlockMap(ctx, req.(*GetInoBlockMap_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _StorageMeta_GetInoBlockMeta_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInoBlockMeta_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageMetaServer).GetInoBlockMeta(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StorageMeta_GetInoBlockMeta_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageMetaServer).GetInoBlockMeta(ctx, req.(*GetInoBlockMeta_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _StorageMeta_UpdateBlockLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateBlockLocation_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageMetaServer).UpdateBlockLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StorageMeta_UpdateBlockLocation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageMetaServer).UpdateBlockLocation(ctx, req.(*UpdateBlockLocation_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _StorageMeta_BatchUpdateBlockLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchUpdateBlockLocation_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageMetaServer).BatchUpdateBlockLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StorageMeta_BatchUpdateBlockLocation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageMetaServer).BatchUpdateBlockLocation(ctx, req.(*BatchUpdateBlockLocation_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _StorageMeta_CreatePhysicalVolume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreatePhysicalVolume_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageMetaServer).CreatePhysicalVolume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StorageMeta_CreatePhysicalVolume_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageMetaServer).CreatePhysicalVolume(ctx, req.(*CreatePhysicalVolume_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _StorageMeta_PatchPhysicalVolume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchPhysicalVolume_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageMetaServer).PatchPhysicalVolume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StorageMeta_PatchPhysicalVolume_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageMetaServer).PatchPhysicalVolume(ctx, req.(*PatchPhysicalVolume_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _StorageMeta_CreateVirtualVolume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateVirtualVolume_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageMetaServer).CreateVirtualVolume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StorageMeta_CreateVirtualVolume_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageMetaServer).CreateVirtualVolume(ctx, req.(*CreateVirtualVolume_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _StorageMeta_CreateReadOnlyVirtualVolume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateReadOnlyVirtualVolume_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageMetaServer).CreateReadOnlyVirtualVolume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StorageMeta_CreateReadOnlyVirtualVolume_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageMetaServer).CreateReadOnlyVirtualVolume(ctx, req.(*CreateReadOnlyVirtualVolume_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _StorageMeta_BindPhysicalVolToVirtualVol_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BindPhysicalVolToVirtualVol_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageMetaServer).BindPhysicalVolToVirtualVol(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StorageMeta_BindPhysicalVolToVirtualVol_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageMetaServer).BindPhysicalVolToVirtualVol(ctx, req.(*BindPhysicalVolToVirtualVol_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _StorageMeta_UnBindPhysicalVolToVirtualVol_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnBindPhysicalVolToVirtualVol_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageMetaServer).UnBindPhysicalVolToVirtualVol(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StorageMeta_UnBindPhysicalVolToVirtualVol_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageMetaServer).UnBindPhysicalVolToVirtualVol(ctx, req.(*UnBindPhysicalVolToVirtualVol_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _StorageMeta_HeartBeat_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(StorageMetaServer).HeartBeat(&storageMetaHeartBeatServer{stream})
}

type StorageMeta_HeartBeatServer interface {
	Send(*HeartBeat_Response) error
	Recv() (*HeartBeat_Request, error)
	grpc.ServerStream
}

type storageMetaHeartBeatServer struct {
	grpc.ServerStream
}

func (x *storageMetaHeartBeatServer) Send(m *HeartBeat_Response) error {
	return x.ServerStream.SendMsg(m)
}

func (x *storageMetaHeartBeatServer) Recv() (*HeartBeat_Request, error) {
	m := new(HeartBeat_Request)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// StorageMeta_ServiceDesc is the grpc.ServiceDesc for StorageMeta service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var StorageMeta_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hugo.v1.meta.StorageMeta",
	HandlerType: (*StorageMetaServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "LoadConfiguration",
			Handler:    _StorageMeta_LoadConfiguration_Handler,
		},
		{
			MethodName: "Statistics",
			Handler:    _StorageMeta_Statistics_Handler,
		},
		{
			MethodName: "BeginTransaction",
			Handler:    _StorageMeta_BeginTransaction_Handler,
		},
		{
			MethodName: "CommitTransaction",
			Handler:    _StorageMeta_CommitTransaction_Handler,
		},
		{
			MethodName: "RollbackTransaction",
			Handler:    _StorageMeta_RollbackTransaction_Handler,
		},
		{
			MethodName: "GetPhysicalVolume",
			Handler:    _StorageMeta_GetPhysicalVolume_Handler,
		},
		{
			MethodName: "GetVirtualVolume",
			Handler:    _StorageMeta_GetVirtualVolume_Handler,
		},
		{
			MethodName: "ListPhysicalVolumes",
			Handler:    _StorageMeta_ListPhysicalVolumes_Handler,
		},
		{
			MethodName: "ListVirtualVolume",
			Handler:    _StorageMeta_ListVirtualVolume_Handler,
		},
		{
			MethodName: "GetInoBlockMap",
			Handler:    _StorageMeta_GetInoBlockMap_Handler,
		},
		{
			MethodName: "GetHistoryBlockMap",
			Handler:    _StorageMeta_GetHistoryBlockMap_Handler,
		},
		{
			MethodName: "GetInoBlockMeta",
			Handler:    _StorageMeta_GetInoBlockMeta_Handler,
		},
		{
			MethodName: "UpdateBlockLocation",
			Handler:    _StorageMeta_UpdateBlockLocation_Handler,
		},
		{
			MethodName: "BatchUpdateBlockLocation",
			Handler:    _StorageMeta_BatchUpdateBlockLocation_Handler,
		},
		{
			MethodName: "CreatePhysicalVolume",
			Handler:    _StorageMeta_CreatePhysicalVolume_Handler,
		},
		{
			MethodName: "PatchPhysicalVolume",
			Handler:    _StorageMeta_PatchPhysicalVolume_Handler,
		},
		{
			MethodName: "CreateVirtualVolume",
			Handler:    _StorageMeta_CreateVirtualVolume_Handler,
		},
		{
			MethodName: "CreateReadOnlyVirtualVolume",
			Handler:    _StorageMeta_CreateReadOnlyVirtualVolume_Handler,
		},
		{
			MethodName: "BindPhysicalVolToVirtualVol",
			Handler:    _StorageMeta_BindPhysicalVolToVirtualVol_Handler,
		},
		{
			MethodName: "UnBindPhysicalVolToVirtualVol",
			Handler:    _StorageMeta_UnBindPhysicalVolToVirtualVol_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "HeartBeat",
			Handler:       _StorageMeta_HeartBeat_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "meta/storage.proto",
}
